# Interfaces

## Interfaces trong Go lร gรฌ?

Trong Go, interface lร kiแปu trแปซu tฦฐแปฃng duy nhแบฅt. Chรบng khรดng yรชu cแบงu khai bรกo rรต rรng viแปc mแปt struct "implement" mแปt interface nhฦฐ trong Java hay C#.

- Go dรนng implicit implementation โ mแปt tรญnh nฤng rแบฅt mแบกnh vร linh hoแบกt.

**Khai bรกo interface trong Go**

```
type Stringer interface {
    String() string
}
```

### ๐ง Khรกi niแปm method set

> Method set lร tแบญp hแปฃp cรกc phฦฐฦกng thแปฉc ฤฦฐแปฃc ฤแปnh nghฤฉa trรชn mแปt kiแปu cแปฅ thแป
> Phแบงn trong interface โ danh sรกch cรกc hรm nhฦฐ String() string โ ฤฦฐแปฃc gแปi lร `method set.`

- Nแบฟu mแปt struct cรณ method tฦฐฦกng แปฉng vแปi toรn bแป method set cแปงa mแปt interface โ nรณ `thแปa mรฃn` interface ฤรณ.
- ฤiแปu nรy รกp dแปฅng tแปฑ ฤแปng vร khรดng cแบงn cรบ phรกp ฤแบทc biแปt.

> Tรนy vรo viแปc bแบกn dรนng value receiver hay pointer receiver, method set cแปงa giรก trแป vร con trแป cรณ thแป khรกc nhau.

**Method set cแปงa value vร pointer khรกc nhau nhฦฐ thแบฟ nรo?**
Vแปi mแปt kiแปu T, cรณ hai tรฌnh huแปng:

- Kiแปu dรนng `T (giรก trแป)`: Method set bao gแปm - Cรกc method cรณ receiver lร T
- Kiแปu dรนng `*T (con trแป)`: Method set bao gแปm - Cรกc method cรณ receiver lร T vร \*T

```
package main

import "fmt"

type Person struct {
    Name string
}

// Method vแปi receiver lร value
func (p Person) SayHello() {
    fmt.Println("Hello, my name is", p.Name)
}

// Method vแปi receiver lร pointer
func (p *Person) ChangeName(newName string) {
    p.Name = newName
}
```

Phรขn tรญch method set:

- Method set cแปงa Person (giรก trแป):
  -SayHello()
- Method set cแปงa \*Person (con trแป):
  - SayHello()
  - ChangeName()

### ๐ Tรชn interface kแบฟt thรบc bแบฑng -er

> ฤรขy lร convention (quy ฦฐแปc) rแบฅt phแป biแบฟn trong Go:

## Interfaces trong Go chรญnh lร โtype-safe duck typing.โ

**๐ฆ Type-Safe Duck Typing lร gรฌ?**

> Trong cรกc ngรดn ngแปฏ ฤแปng nhฦฐ Python, Ruby, JavaScript โ khรดng cแบงn khai bรกo mแปt interface. Chแป cแบงn ฤแปi tฦฐแปฃng cรณ method ฤรบng tรชn thรฌ cรณ thแป truyแปn vรo function. ฤรณ lร duck typing.

**๐ก Go: Cรกch tiแบฟp cแบญn kแบฟt hแปฃp (Hybrid)**
Go dรนng implicit interface:

- Khรดng cแบงn implements.
- Chแป cแบงn struct cรณ ฤแบงy ฤแปง cรกc method lร tแปฑ ฤแปng thแปa mรฃn interface.

```
type Logic interface {
    Process(data string) string
}

type LogicProvider struct{}
func (lp LogicProvider) Process(data string) string {
    return "Processed: " + data
}

type Client struct {
    L Logic
}

func (c Client) Program() {
    c.L.Process("data")
}

func main() {
    c := Client{L: LogicProvider{}}
    c.Program()
}
```

### Embedding โ khรดng chแป dรนng cho struct, mร cรฒn dรนng ฤฦฐแปฃc cho interface.

> Bแบกn cรณ thแป embed interface nรy vรo trong interface khรกc ฤแป tแบกo ra mแปt interface phแปฉc tแบกp hฦกn tแปซ cรกc interface ฤฦกn giแบฃn.

```
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

type ReadCloser interface {
    Reader
    Closer
}

// Cรกch dรนng
func process(rc io.ReadCloser) {
    buf := make([]byte, 100)
    rc.Read(buf)
    rc.Close()
}

```

> ReadCloser lร interface tแปng hแปฃp โ `yรชu cแบงu type phแบฃi implement cแบฃ Read(...) vร Close()`. ฤรขy lร cรกch tแบกo `interface mแป rแปng` trong Go.

#### Embedding Interface in a Struct?

Bแบกn cรณ thแป `nhรบng mแปt interface vรo trong struct` ฤแป:

- `promote cรกc method tแปซ interface`
- lรm cho struct `โhรnh xแปญ nhฦฐโ` interface ฤรณ, miแปn lร nรณ cรณ method phรน hแปฃp.

> Khi bแบกn embed mแปt interface vรo struct, tแปฉc lร bแบกn ฤฦฐa interface ฤรณ vรo struct nhฦฐ mแปt field แบฉn danh:

```
type Printer interface {
    Print()
}

type MyPrinter struct{}

func (m MyPrinter) Print() {
    fmt.Println("Hello from MyPrinter")
}

type Wrapper struct {
    Printer // embedding interface
}
```

> Nแบฟu bแบกn gรกn mแปt MyPrinter vรo field Printer cแปงa Wrapper, bแบกn cรณ thแป gแปi method Print() trแปฑc tiแบฟp trรชn Wrapper.

**Vรญ dแปฅ**

```
package main

import "fmt"

// Interface
type Greeter interface {
    Greet()
}

// Struct implement Greeter
type EnglishGreeter struct{}

func (e EnglishGreeter) Greet() {
    fmt.Println("Hello!")
}

// Embed interface vรo struct
type App struct {
    Greeter // embedded interface
}

func main() {
    app := App{
        Greeter: EnglishGreeter{}, // gรกn implementation vรo interface
    }

    app.Greet() // gแปi trแปฑc tiแบฟp nhแป embedded interface
}
```

- App embed interface Greeter.
- App cรณ thแป gแปi trแปฑc tiแบฟp Greet() nhฦฐ thแป App implement interface nรy โ nhฦฐng thแปฑc ra lร nรณ แปงy quyแปn cho Greeter ฤรฃ ฤฦฐแปฃc gรกn (แป ฤรขy lร EnglishGreeter{}).
- Nแบฟu bแบกn khรดng gรกn Greeter, gแปi app.Greet() sแบฝ gรขy panic do nil interface.

## โ Nguyรชn tแบฏc: Accept Interfaces, Return Structs

### 1. Accept Interfaces (Nhแบญn vรo lร interface) - Tฤng tรญnh linh hoแบกt & decoupling

- Khi viแบฟt hรm hoแบทc method, bแบกn nรชn khai bรกo kiแปu tham sแป lร interface โ chแป cแบงn ฤรบng method set bแบกn sแปญ dแปฅng.
- ฤiแปu nรy lรm cho hรm:
  - `linh hoแบกt` hฦกn (nhแบญn nhiแปu loแบกi type khรกc nhau)
  - `รญt phแปฅ thuแปc hฦกn` (chแป phแปฅ thuแปc vรo hรnh vi, khรดng phแบฃi implementation cแปฅ thแป)

```
type Writer interface {
    Write(p []byte) (n int, err error)
}

func LogMessage(w Writer, msg string) {
    w.Write([]byte(msg))
}
```

> Hรm LogMessage cรณ thแป dรนng vแปi os.Stdout, bytes.Buffer, net.Conn, ... bแบฅt kแปณ type nรo implement Writer.

### 2. Return Structs (Trแบฃ vแป lร struct) - Trรกnh phแปฅ thuแปc khรดng cแบงn thiแบฟt & dแป mแป rแปng

> Khi viแบฟt factory function hoแบทc API, bแบกn nรชn trแบฃ vแป `concrete type (struct)`, `khรดng nรชn trแบฃ vแป interface.`

**๐งฑ Lรฝ do:**
โ Trแบฃ vแป interface lรm tฤng coupling:

- Nแบฟu bแบกn `trแบฃ vแป interface` cแปงa bรชn thแปฉ ba, ngฦฐแปi dรนng code bแบกn sแบฝ `bแป phแปฅ thuแปc luรดn vรo package ฤรณ.`
- ฤiแปu nรy gรขy khรณ khฤn khi:
  - thay ฤแปi package
  - nรขng version (dแป phรก vแปก backward compatibility)
  - mock hay test

โ Interface breaking change:

- Nแบฟu bแบกn `thรชm method vรo mแปt interface,` tแบฅt cแบฃ cรกc type implement interface ฤรณ `phแบฃi cแบญp nhแบญt lแบกi.`
- Nhฦฐng nแบฟu bแบกn thรชm method vรo struct thรฌ client vแบซn dรนng bรฌnh thฦฐแปng nแบฟu hแป khรดng gแปi method mแปi ฤรณ.

**๐งช Vรญ dแปฅ: tแปt vs xแบฅu**
โ Xแบฅu โ trแบฃ vแป interface:

```
func NewLogger() Logger {
    return &fileLogger{}
}
```

Bแบฅt kแปณ ai dรนng NewLogger() `ฤแปu phแปฅ thuแปc vรo interface` Logger. Nแบฟu bแบกn ฤแปi hoแบทc mแป rแปng interface ฤรณ, hแป sแบฝ bแป แบฃnh hฦฐแปng.

โ Tแปt โ trแบฃ vแป struct:

```
func NewFileLogger() *FileLogger {
    return &FileLogger{}
}
```

- Ngฦฐแปi dรนng vแบซn cรณ thแป wrap nรณ bแบฑng interface nแบฟu hแป muแปn.
- Bแบกn cรณ thแป mแป rแปng FileLogger mร khรดng phรก vแปก backward compatibility.

**๐จ Ngoแบกi lแป: Trแบฃ vแป error interface**
ฤรขy lร `ngoแบกi lแป hแปฃp lรฝ duy nhแบฅt` vรฌ:

- error lร interface duy nhแบฅt cรณ sแบตn trong Go.
- Cรณ thแป trแบฃ vแป nhiแปu loแบกi lแปi khรกc nhau.
- Caller chแป cแบงn xแปญ lรฝ theo error, khรดng quan tรขm lร lแปi cแปฅ thแป nรo.

```
func DoSomething() error {
    return errors.New("something went wrong")
}
```

### ๐ง ฤiแปm cแปt lรตi: Interface chแป thแปฑc sแปฑ nil nแบฟu cแบฃ type lแบซn value ฤแปu nil

> โ interface == nil โบ type == nil && value == nil

```
interface {
   type:   *SomeType
   value:  actual value
}

var s *string
fmt.Println(s == nil)  // โ true โ s lร nil pointer

var i interface{}
fmt.Println(i == nil)  // โ true โ i chฦฐa gรกn gรฌ cแบฃ, nil interface (type=nil, value=nil)

i = s
fmt.Println(i == nil)  // โ false โ i ฤang chแปฉa (type=*string, value=nil)
```

####โ Tรกc hแบกi thแปฑc tแบฟ
**โ๏ธ 1. Lแปi logic: bแบกn nghฤฉ giรก trแป nil nhฦฐng thแปฑc ra khรดng phแบฃi**

```
func doSomething(err error) {
	if err == nil {
		fmt.Println("No error")  // โ ฤรขy cรณ thแป khรดng ฤรบng!
	}
}
```

> Nแบฟu err lร mแปt interface error chแปฉa mแปt giรก trแป nil \*MyError, thรฌ err != nil, vร hรm sแบฝ khรดng in ra โNo errorโ nhฦฐ mong ฤแปฃi.
> **โ๏ธ 2. Panic nแบฟu gแปi method trรชn giรก trแป nil bรชn trong interface**

```
type MyType struct{}

func (m *MyType) Do() {
	fmt.Println("Do something")
}

func main() {
	var m *MyType = nil
	var i interface{} = m
	i.(MyTypeInterface).Do()  // ๐ฅ panic: nil pointer dereference
}
```

## The Empty Interface Says Nothing

**๐ 1. interface{} nghฤฉa lร โany typeโ trong Go**
Trong Go, interface{} lร interface trแปng, nghฤฉa lร nรณ khรดng yรชu cแบงu bแบฅt kแปณ method nรo.

> โก๏ธ Vรฌ mแปi type trong Go ฤแปu cรณ รญt nhแบฅt lร zero method, mแปi type ฤแปu โimplementsโ interface{}.

```
var i interface{}
i = 42
i = "hello"
i = SomeStruct{"abc", 123}
```

### ๐ง Vแบญy interface{} dรนng lรm gรฌ?

**1. ๐ฆ Dแปฏ liแปu khรดng biแบฟt trฦฐแปc schema (thฦฐแปng lร JSON)**
Khi ฤแปc tแปซ mแปt nguแปn dแปฏ liแปu linh hoแบกt (JSON, YAML, v.v.), ta khรดng biแบฟt kiแปu cแปฅ thแป lร gรฌ.

```
data := map[string]interface{}{}

contents, err := ioutil.ReadFile("testdata/sample.json")
if err != nil {
    return err
}
json.Unmarshal(contents, &data)
```

> โก๏ธ Sau khi Unmarshal, data["foo"] cรณ thแป lร string, float64, bool, map[string]interface{}... tรนy vรo JSON gแปc.

**2. ๐ Tแปฑ viแบฟt data structure dรนng cho nhiแปu loแบกi dแปฏ liแปu (trฦฐแปc khi Go cรณ generics)**

```
type LinkedList struct {
	Value interface{}
	Next  *LinkedList
}

func (ll *LinkedList) Insert(pos int, val interface{}) *LinkedList {
	if ll == nil || pos == 0 {
		return &LinkedList{Value: val, Next: ll}
	}
	ll.Next = ll.Next.Insert(pos-1, val)
	return ll
}
```

**โ๏ธ 3. Tแบกi sao nรชn trรกnh dรนng interface{}?**

- Khรดng cรณ thรดng tin gรฌ vแป giรก trแป: khรดng biแบฟt type lร gรฌ, khรดng gแปi ฤฦฐแปฃc method nรo.
- Rแบฅt dแป mแบฏc lแปi tแบกi runtime nแบฟu xแปญ lรฝ sai type.
- Khรดng phแบฃi cรกch viแบฟt โidiomaticโ trong Go (trแปซ khi thแปฑc sแปฑ cแบงn).

#### ๐ 4. Vแบญy nแบฟu ฤรฃ dรนng interface{} rแปi, lรm sao lแบฅy giรก trแป ra?

**Type assertion:**

```
val := i.(string)       // panic nแบฟu i khรดng phแบฃi string
val, ok := i.(string)   // an toรn hฦกn
```

**Type switch:**

```
switch v := i.(type) {
case string:
    fmt.Println("Got string:", v)
case int:
    fmt.Println("Got int:", v)
default:
    fmt.Println("Unknown type")
}
```

## Type Assertions and Type Switches

Trong Go, khi lรm viแปc vแปi biแบฟn interface, ฤรดi khi bแบกn cแบงn biแบฟt:

- `Giรก trแป bรชn trong thuแปc kiแปu gรฌ (concrete type)?`
- `Cรณ phแบฃi nรณ implements mแปt interface khรกc khรดng?`

Go cung cแบฅp 2 cรดng cแปฅ chรญnh ฤแป lรm viแปc nรy:

### 1. ๐งฉ Type Assertion โ โTรดi khแบณng ฤแปnh ฤรขy lร kiแปu Xโ - chแป รกp dแปฅng ฤฦฐแปฃc nแบฟu bแบกn biแบฟt trฦฐแปc vรi kiแปu cรณ thแป xแบฃy ra. Dรนng cho 1 kiแปu cแปฅ thแป

```
v, ok := i.(string)
if !ok {
    fmt.Println("Khรดng phแบฃi string")
} else {
    fmt.Println("ฤรขy lร string:", v)
}
```

### 2. ๐ Type Switch โ โTรดi kiแปm tra thแปญ xem nรณ lร kiแปu nรoโ - Kiแปm tra nhiแปu kiแปu cรนng lรบc. Dรนng khi cรณ nhiแปu khแบฃ nฤng vแป kiแปu

```
switch v := i.(type) {
case int:
    fmt.Println("Lร sแป:", v)
case string:
    fmt.Println("Lร chuแปi:", v)
case MyType:
    fmt.Println("Lร kiแปu MyType:", v)
case nil:
    fmt.Println("Giรก trแป lร nil")
default:
    fmt.Println("Khรดng rรต lร kiแปu gรฌ")
}
```

## Function Types Are a Bridge to Interfaces

Bแบกn cรณ thแป biแบฟn mแปt hรm (function) thรnh mแปt โฤแปi tฦฐแปฃngโ cรณ thแป gแปi ฤฦฐแปฃc cรกc phฦฐฦกng thแปฉc (methods) โ bแบฑng cรกch tแบกo mแปt kiแปu hรm (function type) vร thรชm method cho nรณ.

**Vรญ dแปฅ ฤฦกn giแบฃn:**
Giแบฃ sแปญ bแบกn cรณ mแปt hรm xแปญ lรฝ HTTP kiแปu nรy:

```
func myHandler(w http.ResponseWriter, r *http.Request) {
    // Xแปญ lรฝ request แป ฤรขy
}

```

Nhฦฐng Go yรชu cแบงu mแปt ฤแปi tฦฐแปฃng cรณ method ServeHTTP(w, r) ฤแป lรm handler, nhฦฐ interface nรy:

```
type Handler interface {
    ServeHTTP(http.ResponseWriter, *http.Request)
}
```

Vแบญy bแบกn lรm thแบฟ nรo ฤแป dรนng luรดn hรm myHandler lรm Handler?

**Giแบฃi phรกp:**

```
// 1. Tแบกo mแปt kiแปu mแปi โ ฤรณ lร kiแปu hรm:
type HandlerFunc func(http.ResponseWriter, *http.Request)

// 2. Thรชm method ServeHTTP cho kiแปu nรy:
func (f HandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    f(w, r)  // gแปi chรญnh hรm f ฤรณ
}

3. Giแป bแบกn cรณ thแป chuyแปn hรm myHandler thรnh HandlerFunc rแปi dรนng nรณ nhฦฐ mแปt Handler:
var h Handler = HandlerFunc(myHandler)
```

**Tรณm tแบฏt**

- Bแบกn cรณ mแปt hรm (function).
- Bแบกn muแปn hรm ฤรณ ฤฦฐแปฃc xแปญ lรฝ nhฦฐ mแปt ฤแปi tฦฐแปฃng (object) cรณ thแป gแปi method.
- Bแบกn tแบกo kiแปu hรm mแปi (function type).
- Rแปi gรกn thรชm method cho kiแปu hรm ฤรณ.
- Khi gแปi method nรy, nรณ chแป gแปi thแบณng hรm bรชn trong.

Nhฦฐ vแบญy, hรm trแป thรnh mแปt ฤแปi tฦฐแปฃng thแปa mรฃn interface.

**Tแบกi sao lแบกi lรm vแบญy?**

- Trong Go, interface chแป cแบงn 1 method cลฉng rแบฅt mแบกnh.
- Nแบฟu bแบกn chแป cแบงn truyแปn 1 hรm ฤฦกn giแบฃn, thay vรฌ tแบกo mแปt struct phแปฉc tแบกp, bแบกn cรณ thแป tแบญn dแปฅng kiแปu hรm cรณ method.
- ฤiแปu nรy giรบp code ngแบฏn gแปn, linh hoแบกt vร idiomatic (ฤรบng chuแบฉn Go).

> `Bแบกn cรณ hรm ฤฦกn` -> `Bแบกn cแบงn object cรณ method`: Muแปn thแปa interface (cรณ method) -> `Giแบฃi phรกp`: Tแบกo function type + thรชm method gแปi hรm ฤรณ
