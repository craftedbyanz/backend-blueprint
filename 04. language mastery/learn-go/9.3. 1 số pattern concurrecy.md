# Concurrency Practices and Patterns

> C√°c best practices, c√°c pattern ph·ªï bi·∫øn concurrency trong Go.

## Keep Your APIs Concurrency-Free

> Kh√¥ng ƒë·ªÉ ng∆∞·ªùi d√πng API c·ªßa b·∫°n ph·∫£i hi·ªÉu or x·ª≠ l√Ω concurrency.

- N√™n:
  - ·∫®n concurrency b√™n trong impl
  - Cung c·∫•p c√°c method, func, callback-based API ƒë∆°n gi·∫£n
  - N·∫øu c·∫ßn giao ti·∫øp b·∫•t ƒë·ªìng b·ªô, c√¢n nh·∫Øc d√πng callback, context or channel n·ªôi b·ªô kh√¥ng export

### So s√°nh Bad v√† Good API

```
// BAD: exposes internal synchronization
type Downloader struct {
    Done chan struct{}
}
```

Ng∆∞·ªùi d√πng gi·ªù ph·∫£i:

- Ki·ªÉm tra xem Done ƒë√£ ƒë∆∞·ª£c ƒë√≥ng ch∆∞a.

- T·ª± x·ª≠ l√Ω concurrency logic li√™n quan ƒë·∫øn Done.

- R·∫•t d·ªÖ g√¢y goroutine leak, race condition, ho·∫∑c deadlock n·∫øu d√πng sai.

```
// GOOD: hides internal concurrency details
type Downloader struct {
    // private channel or goroutines inside
}

func (d *Downloader) Wait() error {
    // blocks until done internally
    return nil
}
```

or n·∫øu c·∫ßn truy·ªÅn t√≠n hi·ªáu ra ngo√†i, d√πng context.Context:

```
func (d *Downloader) Start(ctx context.Context) error {
    // s·∫Ω h·ªßy khi context b·ªã h·ªßy
    return nil
}
```

### V·∫•n ƒë·ªÅ: Goroutine kh√¥ng tho√°t -> leak

```
func countTo(max int) <-chan int {
    ch := make(chan int)
    go func() {
        for i := 0; i < max; i++ {
            ch <- i
        }
        close(ch)
    }()
    return ch
}
```

#### Tr∆∞·ªùng h·ª£p s·ª≠ d·ª•ng OK:

```
func main() {
    for i := range countTo(10) {
        fmt.Println(i)
    }
}
```

main ƒë·ªçc h·∫øt k√™nh ‚Üí goroutine ho√†n th√†nh ‚Üí OK

#### Tr∆∞·ªùng h·ª£p g√¢y leak:

```
func main() {
    for i := range countTo(10) {
        if i > 5 {
            break
        }
        fmt.Println(i)
    }
}
```

- `main tho√°t s·ªõm,` nh∆∞ng goroutine v·∫´n `ƒëang ch·ªù g·ª≠i ti·∫øp gi√° tr·ªã v√†o ch`

- V√¨ kh√¥ng c√≥ ai ƒë·ªçc ti·∫øp, goroutine b·ªã `block m√£i m√£i t·∫°i ch <- i`

> ƒêi·ªÅu n√†y g·ªçi l√† `goroutin leak`. D√π kh√¥ng l√†m g√¨, nh∆∞ng s·∫Ω b·ªã chi·∫øm t√†i nguy√™n v√† CPU scheduling time

#### Gi·∫£i ph√°p: d√πng (done channel) ƒë·ªÉ h·ªßy goroutine

Ta s·ª≠a l·∫°i countTo ƒë·ªÉ c√≥ th√™m m·ªôt k√™nh done gi√∫p goroutine bi·∫øt khi n√†o n√™n tho√°t:

```
func countTo(max int, done <-chan struct{}) <-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch)
        for i := 0; i < max; i++ {
            select {
            case <-done:
                return // stop if done is closed
            case ch <- i:
            }
        }
    }()
    return ch
}
```

#### C√°ch d√πng:

```
func main() {
    done := make(chan struct{})
    defer close(done)

    for i := range countTo(10, done) {
        if i > 5 {
            break
        }
        fmt.Println(i)
    }
}
```

- defer close(done) s·∫Ω ƒë√≥ng k√™nh khi main k·∫øt th√∫c ho·∫∑c break
- Goroutine b√™n trong countTo s·∫Ω nh·∫≠n t√≠n hi·ªáu t·ª´ done v√† tho√°t s·∫°ch s·∫Ω

## The Done Channel Pattern

> M·∫´u thi·∫øt k·∫ø gi√∫p d·ª´ng goroutine m·ªôt c√°ch an to√†n v√† hi·ªáu qu·∫£, tr√°nh t√¨nh tr·∫°ng goroutine leak khi kh√¥ng c·∫ßn k·∫øt qu·∫£ t·ª´ t·∫•t c·∫£ c√°c t√°c v·ª• song song n·ªØa.

### üîç Ph√¢n t√≠ch v√≠ d·ª• searchData

```
func searchData(s string, searchers []func(string) []string) []string {
    done := make(chan struct{})
    result := make(chan []string)

    for _, searcher := range searchers {
        go func(searcher func(string) []string) {
            select {
            case result <- searcher(s):
            case <-done:
            }
        }(searcher)
    }

    r := <-result
    close(done)
    return r
}
```

#### üéØ M·ª•c ti√™u:

- C√≥ nhi·ªÅu "searcher" (c√°c h√†m t√¨m ki·∫øm) ch·∫°y song song.

- Ch·ªâ l·∫•y k·∫øt qu·∫£ ƒë·∫ßu ti√™n tr·∫£ v·ªÅ.

- Sau khi c√≥ k·∫øt qu·∫£ ƒë·∫ßu ti√™n ‚Üí d·ª´ng t·∫•t c·∫£ c√°c goroutine c√≤n l·∫°i ‚Üí tr√°nh leak.

#### üß† C√°ch ho·∫°t ƒë·ªông:

1. T·∫°o `done` channel

   ```
   done := make(chan struct{})

   ```

   - K√™nh d√πng ƒë·ªÉ g·ª≠i t√≠n hi·ªáu k·∫øt th√∫c cho c√°c goroutine kh√°c.
   - D√πng `struct{} v√¨ n√≥ chi·∫øm 0 byte` ‚Äî ta `ch·ªâ quan t√¢m ƒë·∫øn vi·ªác k√™nh ƒë√£ ƒë√≥ng hay ch∆∞a`, kh√¥ng quan t√¢m gi√° tr·ªã.

2. Ch·∫°y c√°c goroutine t√¨m ki·∫øm song song

   ```
   go func(searcher func(string) []string) {
       select {
       case result <- searcher(s): // N·∫øu ch·∫°y xong s·ªõm, g·ª≠i k·∫øt qu·∫£
       case <-done:                // N·∫øu c√≥ t√≠n hi·ªáu d·ª´ng th√¨ tho√°t lu√¥n
       }
   }(searcher)
   ```

   D√πng select ƒë·ªÉ ch·ªù m·ªôt trong hai tr∆∞·ªùng h·ª£p:

   - searcher(s) ch·∫°y xong v√† g·ª≠i v√†o result.

   - Ho·∫∑c done ƒë∆∞·ª£c ƒë√≥ng, nghƒ©a l√† kh√¥ng c·∫ßn k·∫øt qu·∫£ n·ªØa

3. Nh·∫≠n k·∫øt qu·∫£ ƒë·∫ßu ti√™n: Ch·ªù goroutine ƒë·∫ßu ti√™n tr·∫£ v·ªÅ k·∫øt qu·∫£.

   ```
   r := <-result

   ```

4. ƒê√≥ng done ƒë·ªÉ b√°o hi·ªáu d·ª´ng t·∫•t c·∫£ goroutine c√≤n l·∫°i
   ```
   close(done)
   ```
   - Khi m·ªôt searcher tr·∫£ k·∫øt qu·∫£, c√°c goroutine kh√°c s·∫Ω ƒë∆∞·ª£c `b·ªè qua` nh·ªù case <-done.
   - Tr√°nh ƒë·ªÉ ch√∫ng ti·∫øp t·ª•c x·ª≠ l√Ω kh√¥ng c·∫ßn thi·∫øt ‚Üí gi·∫£m t·∫£i h·ªá th·ªëng.

### T·ªïng k·∫øt

∆Øu ƒëi·ªÉm - `Ti·∫øt ki·ªÉu t√†i nguy√™n`: d·ª´ng s·ªõm c√°c goroutine kh√¥ng c·∫ßn thi·∫øt - `Tr√°nh goroutine leak`: C√°c goroutine c√≥ c√°ch ƒë·ªÉ tho√°t - D·ªÖ ƒë·ªçc, b·∫£o tr√¨

**M·∫´u n√†y c·ª±c k·ª≥ ph√π h·ª£p v·ªõi c√°c b√†i to√°n:** "ƒëua" gi·ªØa nhi·ªÅu ngu·ªìn data (race for first)

> Trong th·ª±c t·∫ø, c√≥ th·ªÉ d√πng context.Context ƒë·ªÉ l√†m vi·ªác t∆∞∆°ng t·ª± nh∆∞ng `linh ho·∫°t h∆°n` (deadline, timeout, truy·ªÅn xu·ªëng nhi·ªÅu t·∫ßng).

## Pattern: Tr·∫£ v·ªÅ h√†m h·ªßy - cancel function: ƒêi·ªÅu khi·ªÉn goroutine v√† t√†i nguy√™n li√™n quan.

### üîç Ph√¢n t√≠ch v√≠ d·ª•: countTo v·ªõi cancel function

H√†m countTo

```
func countTo(max int) (<-chan int, func()) {
    ch := make(chan int)
    done := make(chan struct{})

    cancel := func() {
        close(done)
    }

    go func() {
        for i := 0; i < max; i++ {
            select {
            case <-done:
                return
            case ch <- i:
            }
        }
        close(ch)
    }()

    return ch, cancel
}
```

**√ù t∆∞·ªüng ch√≠nh:**

- ch: Channel tr·∫£ v·ªÅ d·ªØ li·ªáu (ƒë·∫øm t·ª´ 0 ƒë·∫øn max)
- done: Channel ƒëi·ªÅu khi·ªÉn vi·ªác d·ª´ng goroutine
- cancel: H√†m ƒë√≥ng done, ƒë·ªÉ b√°o goroutine k·∫øt th√∫c
- select: Ch·ªçn gi·ªØa vi·ªác g·ª≠i d·ªØ li·ªáu v√† vi·ªác b·ªã d·ª´ng b·ªüi done

**üß† C√°ch ho·∫°t ƒë·ªông:**
main() nh·∫≠n l·∫°i: - ch ‚Äî channel k·∫øt qu·∫£ - cancel ‚Äî h√†m ƒë·ªÉ d·ª´ng goroutine

```
func main() {
    ch, cancel := countTo(10)
    for i := range ch {
        if i > 5 {
            break
        }
        fmt.Println(i)
    }
    cancel()
}
```

**ƒêi·ªÅu g√¨ x·∫£y ra ·ªü ƒë√¢y?**

- for i := range ch ƒë·ªçc t·ª´ng gi√° tr·ªã.
- Khi i > 5, v√≤ng l·∫∑p break.
- Nh∆∞ng n·∫øu kh√¥ng g·ªçi cancel(), goroutine b√™n trong countTo v·∫´n ti·∫øp t·ª•c ch·∫°y, v√¨ n√≥ ƒëang b·ªã k·∫πt khi g·ª≠i v√†o ch.
- cancel() ƒë√≥ng done, gi√∫p goroutine k·∫øt th√∫c s·∫°ch s·∫Ω qua select.

**‚úÖ L·ª£i √≠ch c·ªßa vi·ªác d√πng cancel function**

- Gi·∫£i ph√≥ng goroutine: Tr√°nh goroutine leak khi kh√¥ng c·∫ßn ti·∫øp t·ª•c
- T√°ch bi·ªát giao di·ªán v√† ƒëi·ªÅu khi·ªÉn: Kh√¥ng c·∫ßn expose done, ch·ªâ expose cancel
- Linh ho·∫°t cho cleanup: C√≥ th·ªÉ th√™m logic d·ªçn d·∫πp kh√°c trong cancel()
- Th·ªëng nh·∫•t v·ªõi context: C√°ch n√†y t∆∞∆°ng t·ª± nh∆∞ context.WithCancel ‚Üí d·ªÖ t√≠ch h·ª£p v√†o h·ªá th·ªëng l·ªõn

**Khi n√†o n√™n d√πng m·∫´u n√†y?**

- Khi b·∫°n c√≥ m·ªôt goroutine d√†i h·∫°n (stream, watcher, processor) v√† mu·ªën:

  - `ch·ªß ƒë·ªông h·ªßy b·ªè` t·ª´ b√™n ngo√†i.
  - `d·ªçn d·∫πp t√†i nguy√™n` m·ªôt c√°ch an to√†n.

- Khi b·∫°n c·∫ßn `giao ti·∫øp r√µ r√†ng` gi·ªØa ph·∫ßn g·ªçi (caller) v√† ph·∫ßn ch·∫°y song song (callee).

**‚úÖ T√≥m l·∫°i:**

- B·∫°n `kh√¥ng n√™n expose tr·ª±c ti·∫øp done channel.`
- Thay v√†o ƒë√≥, `tr·∫£ v·ªÅ m·ªôt cancel() function,` c√≥ th·ªÉ ƒë√≥ng done v√† th·ª±c hi·ªán c√°c h√†nh ƒë·ªông d·ªçn d·∫πp kh√°c.
- ƒê√¢y l√† c√°ch Go d√πng ƒë·ªÉ `ƒë√≥ng g√≥i logic h·ªßy b·ªè`, t·∫°o n√™n c√°c API d·ªÖ d√πng v√† an to√†n h∆°n.

### Khi n√†o n√™n d√πng buffered channel thay v√¨ unbuffered channels

`Buffered channel` n√™n d√πng khi b·∫°n:

1. Bi·∫øt tr∆∞·ªõc s·ªë l∆∞·ª£ng goroutine ƒë∆∞·ª£c t·∫°o
2. Mu·ªën `gi·ªõi h·∫°n` s·ªë l∆∞·ª£ng goroutine ƒëang ho·∫°t ƒë·ªông ƒë·ªìng th·ªùi
3. Mu·ªën `gi·ªõi h·∫°n h√†n ƒë·ª£i c√¥ng vi·ªác` (workload queue)

Ng∆∞·ª£c l·∫°i, `unbuffered channels` d√πn khi: - D·ªÖ hi·ªÉu, ho·∫°t ƒë·ªông gi·ªëng nh∆∞ `b√†n giao tr·ª±c ti·∫øp` (hand-off): b√™n g·ª≠i `ch·ªù` b√™n nh·∫≠n.

**V√≠ d·ª•: Buffered channel v√† Goroutine ƒë·ªìng b·ªô**

```
func processChannel(ch chan int) []int {
    const conc = 10
    results := make(chan int, conc)

    for i := 0; i < conc; i++ {
        go func(){
            v := <- ch
            results <- process(v)
        }()
    }

    var out []int
    for i := 0; i < conc; i++ {
        out = append(out, <- results)
    }

    return out
}
```

**L√Ω do buffered channel l·∫°i ph√π h·ª£p**

- V√¨ ta `bi·∫øt tr∆∞·ªõc s·ªë l∆∞·ª£ng goroutine` ƒëang ch·∫°y (conc = 10)
- M·ªói goroutine ch·ªâ g·ª≠i `m·ªôt gi√° tr·ªã duy nh·∫•t` v√†o results
- N·∫øu d√πng `unbeffered channel` ·ªü ƒë√¢y:
  - Goroutine s·∫Ω `b·ªã block` t·∫°i results <- ... n·∫øu `main ch∆∞a s·∫µn s√†ng ƒë·ªçc`
  - ƒêi·ªÅu nay c√≥ th·ªÉ g√¢y `deadlock or hi·ªáu nƒÉng gi·∫£m`

#### Khi n√†o kh√¥ng n√™n d√πng buffered channels?

- Kh√¥ng r√µ s·ªë l∆∞·ª£ng goroutine s·∫Ω ch·∫°y: D·ªÖ `overflow`, block kh√¥ng ki·ªÉm so√°t
- Kh√¥ng ki·ªÉm tra k·ªπ tr·∫°ng th√°i buffer: D·ªÖ b·ªã `goroutine leak or deadlock`
- D√πng nh∆∞ queue v√¥ h·∫°n: Go kh√¥ng h·ªó tr·ª£ buffer v√¥ h·∫°n -> d·ªÖ g√¢y `out of memory`

**T·ªïng k·∫øt**

- D√πng `Unbuffered channel`: Khi c·∫ßn ƒë·ªìng b·ªô tr·ª±c ti·∫øp gi·ªØa sender v√† receiver
- D√πng `Buffered channel`: Khi b·∫°n bi·∫øt:
  - S·ªë l∆∞·ª£ng goroutine
  - C·∫ßn gi·ªõi h·∫°n s·ªë l∆∞·ª£ng c√¥ng vi·ªác
  - c·∫ßm gi·∫£m block trong c√¥ng vi·ªác thu th·∫≠p data

## Pattern Backpressure - c√°ch d√πng select + buffered channel ƒë·ªÉ gi·ªõi h·∫°n s·ªë l∆∞·ª£ng c√¥ng vi·ªác ƒëang x·ª≠ l√Ω ƒë·ªìng th·ªùi.

### Backpressure l√† g√¨?

`Backpressure` l√† 1 c∆° ch·∫ø gi√∫p h·ªá th·ªëng `ch·∫≠m l·∫°i ho·∫∑c t·ª´ ch·ªëi nh·∫≠n th√™m c√¥ng vi·ªác khi qu√° t·∫£i`, thay v√¨ c·ªë x·ª≠ l√Ω t·∫•t c·∫£.

> Tr√°nh `s·∫≠p h·ªá th·ªëng, OOM, timeout h√†ng lo·∫°t, ...`

### Gi·∫£i th√≠ch code

_\*\*PressureGauge_

```
type PressureGauge struct {
    ch chan struct{}
}
```

- ƒê√¢y l√† 1 ki·ªÉu data qu·∫£n l√Ω √°p l·ª±c h·ªá th·ªëng b·∫±ng 1 channel d·∫°ng `buffer`
- Channel n√†y d√πng nh∆∞ `m·ªôt pool token` (gi·ªõi h·∫°n song song)

**New(limit int)**

```
func New(limit int) *PressureGauge {
    chn := make(chan struct{}, limit)
    for i := 0; i < limit; i++ {
        ch <- struct{}{}
    }
    return &PressureGauge{ch}
}
```

- T·∫°o 1 PressureGauge ch·ª©a limit tokens ban ƒë·∫ßu.
- M·ªói token l√† 1 struct{}{} r·ªóng (ti·∫øt ki·ªám b·ªô nh·ªõ, kh√¥ng mang data g√¨)
- Gi·ªëng nh∆∞ 1 `semaphore`: m·ªói token ƒë·∫°i di·ªán cho `1 ph√©p x·ª≠ l√Ω c√≤n kh·∫£ nƒÉng`.

**Process(f func()) error**

```
func (pg *PressureGauge) Process(f func()) error {
    select {
    case <-pg.ch:           // l·∫•y 1 token
        f()                 // Ch·∫°y x·ª≠ l√Ω
        pg.ch <- struct{}{} // tr·∫£ l·∫°i token
        return nil
    default:
        return errors.New("no more capacity")
    }
}
```

- N·∫øu c√≥ token: ch·∫°y f(), sau ƒë√≥ `tr·∫£ l·∫°i token`
- N·∫øu kh√¥ng c√≥ token: r∆°i v√†o default -> t·ª´ ch·ªëi x·ª≠ l√Ω -> tr·∫£ l·ªói
- T·∫•t c·∫£ ƒëi·ªÅu n√†y th·ª±c hi·ªán `1 c√°ch non-blocking` nh·ªù select.

**·ª®ng d·ª•ng v·ªõi HTTP Server**

```
func doThingThatShouldBeLimited() string {
    time.Sleep(2 * time.Second)
    return "done"
}

func main() {
    pg := New(10) // gi·ªõi h·∫°n 10 goroutine ƒëang ch·∫°y ƒë·ªìng th·ªùi
    http.HandleFunc("/request", func(w http.ResponseWriter, r *http.Request) {
        err := pg.Process(func() {
            w.Write([]byte(doThingThatShouldBeLimited()))
        })

        if err != nil {
            w.WriteHeader(http.StatusTooManyRequests)
            w.Write([]byte("Too many requests"))
        }
    })

    http.ListenAndServe(":8080", nil)
}
```

- N·∫øu ƒëang c√≥ <= 10 requests: ti·∫øp t·ª•c x·ª≠ l√Ω
- N·∫øu qu√° t·∫£i: tr·∫£ 420 "t√¥ many requests"

**L·ª£i √≠ch**

- Tr√°nh `t·∫Øc ngh·∫Ωn` CPU, memoru, I/O
- D·ªÖ ƒëi·ªÅu ch·ªânh (ch·ªâ c·∫ßn thay ƒë·ªïi gi√° tr·ªã limit)
- Kh√¥ng c·∫ßn ƒë·∫øn sync.Mutex, WaitGroup, queue ph·ª©c t·∫°p.

> C·∫ßn gi·ªõi h·∫°n t√†i nguy√™n ƒë√¥ng th·ªùi c√≥ th·ªÉ s·ª≠ d·ª•ng pattern n√†y.

## K·ªπ thu·∫≠t v√¥ hi·ªáu h√≥a 1 case trong select

### T·∫°i sao c·∫ßn "turn off" 1 case trong select?

Khi ta ƒëang `ƒë·ªçc t·ª´ nhi·ªÅu channel c√πng l√∫c b·∫±ng select`, n·∫øu `1 channel b·ªã ƒë√≥ng (closed)`

- select v·∫´n c√≥ th·ªÉ ch·ªçn case ƒë√≥
- `chan <- lu√¥n b·ªã block n·∫øu channel ƒë√≥ng.`
- <-chan s·∫Ω `tr·∫£ v·ªÅ zero value + ok == false` n·∫øu channel ƒë√£ b·ªã ƒë√≥ng.

> N·∫øu ta kh√¥ng x·ª≠ l√Ω, ch∆∞∆°ng tr√¨nh s·∫Ω c·ª© ti·∫øp t·ª•c `ƒë·ªçc c√°c gi√° tr·ªã r√°c (zero value) t·ª´ channel ƒë√£ ƒë√≥ng`

**Gi·∫£i ph√°p: ƒê·∫∑t channel = nil**
ƒê√¢y l√† c√°ch "t·∫Øt" h·∫≥n 1 case trong select:

```
in = nil
```

- Channel nil l√† `kh√¥ng th·ªÉ g·ª≠i/nh·∫≠n`
- M·ªôt channel kh√¥ng bao gi·ªù ch·ªçn case m√† li√™n quan t·ªõi nil channel

**V√≠ d·ª• c·ª• th·ªÉ ph√¢n t√≠ch**

```
// in and in2 are channels, done is a done channel.
for {
    select {
    case v, ok := <-in:
        if !ok {
            in = nil // channel ƒë√£ ƒë√≥ng, t·∫Øt case n√†y - the case will never succeed again!
            continue
        }
        // x·ª≠ l√Ω v - process the v that was read from in
    case v, ok := <-in2:
        if !ok {
            in2 = nil // t·∫Øt case ƒë·ªçc in2 - the case will never succeed again!
            continue
        }
        // x·ª≠ l√Ω v - process the v that was read from in2
    case <-done:
        return
    }
}
```

**Di·ªÖn gi·∫£i**

- `Ban ƒë·∫ßu` in, in2 ƒë·ªÅu l√† channel h·ª£p l·ªá -> `select ch·ªçn ƒë∆∞·ª£c b·∫•t k·ª≥ case n√†o`
- Khi in or in2 b·ªã ƒë√≥ng (ok == false) -> ta g√°n in = nil -> case t∆∞∆°ng ·ª©ng (case channel b·ªã ƒë√≥ng) `kh√¥ng bao gi·ªù ƒëc ch·ªçn n·ªØa`
- Gi√∫p ch∆∞∆°ng tr√¨nh `kh√¥ng ƒë·ªçc r√°c v√† kh√¥ng t·ªën CPU`
- case <-done s·∫Ω lu√¥n c√≤n ho·∫°t ƒë·ªông ƒë·ªÉ tho√°t kh·ªèi v√≤ng l·∫∑p.

### Kƒ© thu·∫≠t n√†y d√πng trong TH:

- `Fan-in` t·ª´ nhi·ªÅu channel
- G·ªôp data t·ª´ nhi·ªÅu ngu·ªìn concurrent
- C√°c pipeline x·ª≠ l√Ω b·∫•t ƒë·ªìng b·ªô
- `Merge c√°c channel` (r·∫•t ph·ªï bi·∫øn)

### T√≥m t·∫Øt k·ªπ thu·∫≠t

- **T√¨nh hu·ªëng** Channel b·ªã ƒë√≥ng -> `C√°ch x·ª≠ l√Ω`: G√°n channel = nil ƒë·ªÉ t·∫Øt case trong select
- **T√¨nh hu·ªëng** Mu·ªën h·ªßy select to√†n b·ªô -> `C√°ch x·ª≠ l√Ω`: S·ª≠ d·ª•ng done channel or context.Context

## Pattern: C√°ch l√†m time out 1 ƒëo·∫°n code

> Pattern n√†y gi·ªõi h·∫°n th·ªùi gian t·ªëi ƒëa ƒë·ªÉ 1 c√¥ng vi·ªác ho√†n th√†nh.

```
func timeLimit() (int, error) {
    var result int
    var err error
    done := make(chan struct{})

    // 1. Kh·ªüi ch·∫°y c√¥ng vi·ªác ch√≠nh trong 1 goroutine
    go func() {
        result, err = doSomeWork()
        close(done) // b√°o hi·ªáu l√† xong
    }

    // 2. Ch·ªçn gi·ªØa vi·ªác ch·ªù c√¥ng vi·ªác xong or ch·ªù timeout
    select {
    case <-done:
        // c√¥ng vi·ªác ƒë√£ ho√†n th√†nh tr∆∞·ªõc timeout
        return result, err
    case <-time.After(5 * time.Second):
        // sau 5s v·∫´n ch∆∞a xong -> timeout
        return 0, errors.New("work time out")
    }
}
```

**Gi·∫£i th√≠ch**

1. T·∫°o channel t√≠n hi·ªáu done
   - D√πng make(chan struct{}) v√¨ `ch·ªâ c·∫ßn t√≠n hi·ªáu ƒë√≥ng channel` kh√¥ng c·∫ßn truy·ªÅn data g√¨.
2. Ch·∫°y c√¥ng vi·ªác b·∫•t ƒë·ªìng b·ªô.
   - Trong goroutine ch√∫ng ta g·ªçi doSomeWork(), g√°n k·∫øt qu·∫£ v√†o bi·∫øn result, err r·ªìi close(done) ƒë·ªÉ b√°o ho√†n th√†nh
3. S·ª≠ d·ª•ng select 2 case
   - case <- done: N·∫øu goroutine ho√†n th√†nh tr∆∞·ªõc, ƒë·ªçc t·ª´ done th√†nh c√¥ng -> tr·∫£ v·ªÅ k·∫øt qu·∫£
   - case <-time.After(5 \* time.Second): Sau 5s ch∆∞a c√≥ t√≠n hi·ªáu done -> timeout, tr·∫£ l·ªói.

**L∆∞u √Ω**

- `Goroutine "doSomeWork"` v·∫´n `ti·∫øp t·ª•c ch·∫°y` n·∫øu timeout x·∫£y ra tr∆∞·ªõc khi n√≥ ƒë√≥ng done.
  - V√¨ ta `kh√¥ng ƒë·ªçc` k·∫øt qu·∫£ sau khi timeout, k·∫øt qu·∫£ ƒë√≥ b·ªã `b·ªè qua`, nh∆∞ng goroutine v·∫´n chi·∫øm t√†i nguy√™n cho ƒë·∫øn khi n√≥ k·∫øt th√∫c t·ª± nhi√™n
  - N·∫øu doSomeWork l√† c√¥ng vi·ªác n·∫∑ng or v√¥ h·∫°n -> g√¢y ra `goroutine leak`
  - N·∫øu kh√¥ng mu·ªën vi·ªác ƒë√≥ ti·∫øp t·ª•c ti√™u th·ª• t√†i nguy√™n, c·∫ßn d√πng context cancellation ƒë·ªÉ signal cho goroutine d·ª´ng s·ªõm

**H·ªßy b·ªè job v·ªõi context** ƒë·ªÉ `d·ª´ng ngay l·∫≠p t·ª©c` c√¥ng vi·ªác khi timeout or khi ta kh√¥ng c√≤n ch·ªù k·∫øt qu·∫£ n·ªØa

> Ta s·∫Ω d√πng context.Context ƒë·ªÉ x·ª≠ l√Ω

```
func timeLimitWithContext(parent context.Context) (int, error) {
    // T·∫°o context con c√≥ Timeout
    ctx, cancel := context.WithTimeout(parent, 5 * time.Second)
    defer cancel()

    resultCh := make(chan int, 1)
    erCh     := make(chan error, 1)

    go func() {
        res, err := doSomeWork(ctx) // doSomeWork n√™n t√¥n tr·ªçng ctx
        resultCh <- res
        erCh <- err
    }()

    select {
    case res := <-resultCh:
        return res, <-erCh
    case <-ctx.Done():
    // ctx.Err() s·∫Ω l√† context.DeadlineExceeded n√™ys timeout
        return 0, ctx.Err()
    }
}
```

- `contex.WithTimeout` t·ª± ƒë·ªông t·∫°o1 channel ctx.Done() s·∫Ω `ƒë√≥ng` say th·ªùi h·∫°n, v√† ctx.Err() tr·∫£ v·ªÅ DeadlineExceeded.
- goroutine trong doSomeWork(ctx) c·∫ßn theo d√µi `ctx.Done()` ƒë·ªÉ c√≥ th·ªÉ d·ª´ng s·ªõm:
  ```
  func doSomeWork(ctx context.Context) (int, error) {
      // v√≠ d·ª•: loop, I/O
      select {
      case <-ctx.Done():
          return 0, ctx.Err()
      case <-time.After(5 * time.Secound):
          // k·∫øt th√∫c c√¥ng vi·ªác gi·∫£ ƒë·ªãnh
      }
      return 42, nil
  }
  ```

## Patten: s·ª≠ d·ª•ng WaitGroup ƒë·ªÉ ƒë·ªìng b·ªô goroutine

**Khi n√†o d√πng sync.WaitGroup**

- D√πng khi c√≥ `nhi·ªÅu goroutine` ch·∫°y song song v√† ta c·∫ßn `ƒë·ª£i` cho t·∫•t c·∫£ ch√∫ng `xong vi·ªác` tr∆∞·ªõc khi:
  - k·∫øt th√∫c ch∆∞∆°ng tr√¨nh
  - ƒë√≥ng 1 channel chung
  - tr·∫£ v·ªÅ k·∫øt qu·∫£ t·ªïng h·ª£p
- N·∫øu ch·ªâ ƒë·ª£i `m·ªôt goroutine` ta c√≥ th·ªÉ d√πng `done channel pattern`
- Nh∆∞ng v·ªõi `n goroutine` WaitGroup r√µ r√†ng v√† ƒë·∫πp h∆°n.

> Khi ta cos nhi·ªÅu goroutine ƒë·ªôc l·∫≠p ghi chung tr√™n c√πng 1 channel out, v√† kh√¥ng c√≥ goroutine n√†o ƒë·∫£m b·∫£o ƒë·ªçc h·∫øt t·ª´n channel con theo th·ª© t·ª± th√¨ ta c·∫ßn 1 goroutine monitoring.
>
> 1. WaitGroup ƒë·∫øm xem bao nhi√™u worker ƒë√£ xong
>
> 2. Khi ƒë·ªß, monitor g·ªçi close(out)

- C√≤n n·∫øu rpoducer `t·ª± ƒë√≥ng` channel sau khi xong or b·∫°n c√≥ 1 goroutine fa-in r√µ r√†ng ƒë√≥ng channel cu·ªëi th√¨ th√¨ ch·ªâ c·∫ßn for-range -> `WaitGroup l√† d∆∞ th·ª´a`
  **Code**

```
var wg sync.WaitGroup   // zero value ƒë√£ usable

wg.Add(n)               // tƒÉng counter l√™n n (s√¥ goroutine c·∫ßn ƒë·ª£i)
go func() {
    defer wg.Done()     // gi·∫£m counter 1 khi goroutine k·∫øt th√∫c
    doWork()
}()

wg.Wait()               // block cho ƒë·∫øn khi counter = 0
```

**T·∫°i sao kh√¥ng truy·ªÅn wg v√†o h√†m**
Trong v√≠ d·ª•, ngta d√πng `closure` ƒë·ªÉ capture wg thay v√¨:

```
// Tr√°nh: truy·ªÅn wg (copy) v√†o h√†m, v√¨ Done() s·∫Ω gi·∫£m counter c·ªßa b·∫£n copy
go func(wg sync.WaitGroup) {
    def wg.Done()
    doWork()
}(wg)
```

N·∫øu kh√¥ng d√πng con tr·ªè or closure ban s·∫Ω gi·∫£m counter tr√™n `b·∫£n sao` c·ªßa wg -> Wait() tr√™n b·∫£n g·ªëc s·∫Ω `ch·ªù m√£i`

**V√≠ d·ª• th·ª±c t·∫ø: Process and Gather**

M·ª•c ƒë√≠ch: - C√≥ channel ƒë·∫ßu v√†o in ch·ª©a c√°c gi√° tr·ªã c·∫ßn x·ª≠ l√Ω - D√πng num goroutine ƒë·ªÉ `x·ª≠ l√Ω song song` - processor - Thu v·ªÅ k·∫øt qu·∫£ channel out, r·ªìi tr·∫£ v·ªÅ slice k·∫øt qu·∫£.

```
func processAndGather(in <-chan int, processor func(int) int, num int) []int {
    // I/ Worker pool
    out := make(chan int, num)
    var wg sync.WaitGroup
    wg.Add(num)

    // 1. Lauch worker goroutines - L·∫∑p range ƒë·ªÉ nh·∫≠n gi√° tr·ªã
    for i := 0; i < num; i++ {
        go func() {
            defer wg.Done()
            for v := range in { // Khi in ƒë√≥n v√† loop k·∫øt th√∫c -> g·ªçi wg.Done() r·ªìi exit
                out <- processor(v) // x·ª≠ l√Ω processor v√† g·ª≠i k·∫øt qu·∫£ v·ªÅ out
            }
        }()
    }

    // II/ Monitoring goroutines
    // 2. Goroutine gi√°m s√°t, ƒë√≥ng "out" khi m·ªçi worker xong vi·ªác
    go func() {
        wg.Wait()
        close(out)
    }()

    // 3. ƒê·ªçc k·∫øt qu·∫£ t·ª´ "out" cho t·ªõi khi n√≥ ƒë√≥ng
    var results []int
    for v := range out {
        results = append(results, v)
    }
    return results
}
```

**L∆∞u √Ω khi d√πng WaitGroup**

- Kh√¥ng ph·∫£i l·ª±a ch·ªçn ƒë·∫ßu ti√™n: N·∫øu kh√¥ng c·∫ßn cleanup (v√≠ d·ª• ƒë√≥ng channel) c√≥ th·ªÉ ch·ªâ d√πn `fan-in v·ªõi channel` v√† c√≤ng for-range k·∫øt th·ª©c khi channel ƒë√≥ng.
- Kh√¥ng l·∫°m d·ª•ng: WaitGroup ch·ªâ ƒë·ªÉ `ƒë·ª£i` kh√¥ng d√πng ƒë·ªÉ truy·ªÅn data gi·ªØa c√°c Go

## Pattern: Kh·ªëi code ch·ªâ ƒë∆∞·ª£c th·ª±c thi `duy nh·∫•t 1 l·∫ßn` b·∫•t k·ªÉ ƒë∆∞·ª£c g·ªçi t·ª´ bao nhi√™u gorutine kh√°c nhau:

**Th∆∞·ªùng trong code server ta code theo kh·ªüi t·∫°o t√†i nguy√™n l·∫ßn l∆∞·ª£t th√¨ th∆∞·ªùng kh√¥ng c·∫ßn s·ª≠ d·ª•ng pattern n√†y**

**1.V·∫•n ƒë·ªÅ c·∫ßn gi·∫£i quy·∫øt**

- ƒê√¥i khi ta c·∫ßn `layzy initialization`: kh·ªüi t·∫°o 1 t√†i nguy√™n ch·∫≠m (k·∫øt n·ªëi db, t·∫£i config, parser) `ch·ªâ g·ªçi l·∫ßn ƒë·∫ßu` v√† `ch·ªâ l√†m 1 l·∫ßn` trong su·ªët v√≤ng ƒë·ªùi ·ª©ng d·ª•ng
- Kh√¥ng n√™n d√πng init() cho t·∫•t c·∫£, v√¨:
  - init() ch·∫°y ngay khi package ƒë∆∞·ª£c load, d√π c√≥ c·∫ßn hay kh√¥ng
  - Kh√¥ng ki·ªÉm so√°t th·ª© t·ª± ch·∫°y, kh√≥ t√πy bi·∫øn

**2. sync.Once l√† g√¨?**

- sync.Once (trong package sync) l√† 1 struct nh·ªè g·ªçn, zero value ƒë√£ usable
- Ph∆∞∆°ng th·ª©c `Do(f func())` ƒë·∫£m b·∫£n func f ch·ªâ ƒë∆∞·ª£c `g·ªçi 1 l·∫ßn duy nh·∫•t` b·∫•t k·ªÉ bao nhi√™u goroutine g·ªçi Do.

**3. Code**

```
type SlowComplicatedParser interface {
    Parse(string) string
}

var (
    parser SlowComplicatedParser
    once   sync.Once
)

func Parse(dataToParse string) string {
    // L·∫ßn ƒë·∫ßu g·ªçi, initParser() ƒë∆∞·ª£c th·ª±c thi
    once.Do(func() {
        parser = initParser()
    })
    // Nh·ªØng l·∫ßn sau, closure ·ªü tr√™n kh√¥ng ch·∫°y l·∫°i
    return parser.Parse(dataToParse)
}

func initParser() SlowComplicatedParser {
    // Kh·ªüi t·∫°o parser ph·ª©c t·∫°p, ch·∫≠m
    // V√≠ d·ª•: ƒë·ªçc file, build trie, load model, v.v.
}
```

- parser v√† once l√† bi·∫øn package-level.
- `Zero value` c·ªßa once (m·ªôt l·∫ßn ch∆∞a ƒë∆∞·ª£c th·ª±c thi) ƒë√£ s·∫µn s√†ng d√πng.
- `Kh√¥ng` ƒë∆∞·ª£c copy once (m·ªói b·∫£n sao gi·ªØ tr·∫°ng th√°i ri√™ng); n√™n lu√¥n khai b√°o `ngo√†i` function, kh√¥ng kh·ªüi t·∫°o m·ªõi trong function.

> once.Do n·ªôi b·ªô d√πng atomic v√† mutex ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ `G·ªåI m·ªôt l·∫ßn duy nh·∫•t`, ngay c·∫£ khi c√≥ `nhi·ªÅu goroutine` c√πng g·ªçi Do song song.
>
> C√°c goroutine g·ªçi sau khi ƒë√£ th·ª±c thi xong s·∫Ω skip v√† ti·∫øp t·ª•c, kh√¥ng block.

**4. L∆∞u √Ω khi d√πng**

- `Khai b√°o` sync.Once `·ªü c·∫•p package` ho·∫∑c trong struct n·∫øu b·∫°n mu·ªën tie ƒë·∫ßu cho m·ªói instance.
- `Kh√¥ng` khai b√°o sync.Once trong function, v√¨ m·ªói l·∫ßn g·ªçi function s·∫Ω t·∫°o instance m·ªõi ‚Üí kh√¥ng ƒë·∫£m b·∫£o ‚Äúm·ªôt l·∫ßn duy nh·∫•t‚Äù.
- Ph√π h·ª£p cho `lazy init, singleton pattern, t·∫°o connection pool, build cache, v.v.`

## Pattern GatherAndProcess ho√†n ch·ªânh - ƒë·∫ßy ƒë·ªß context timeout, goroutine, channel, select, error handling, v√† ph·ªëi h·ª£p x·ª≠ l√Ω gi·ªØa c√°c b∆∞·ªõc A, B, C.

**M√¥ ph·ªèng b√†i to√°n:**

- G·ª≠i d·ªØ li·ªáu ƒë·∫øn `service A` v√† `service B` song song.
- Khi `c·∫£ hai` c√≥ k·∫øt qu·∫£ `th√†nh c√¥ng`, `g·ªôp` l·∫°i th√†nh `input` cho `service C`.
- K·∫øt qu·∫£ t·ª´ C l√† output cu·ªëi c√πng.
- To√†n b·ªô qu√° tr√¨nh ph·∫£i ho√†n t·∫•t trong 50ms, n·∫øu kh√¥ng th√¨ timeout ho·∫∑c fail.

**Code**

```
package main

import (
	"context"
	"errors"
	"fmt"
	"time"
)

// --- M√¥ ph·ªèng c√°c ki·ªÉu d·ªØ li·ªáu ---
type Input struct {
	A string
	B string
}

type AOut string
type BOut string
type CIn struct {
	A AOut
	B BOut
}
type COut string

// --- M√¥ ph·ªèng c√°c service ---
func getResultA(ctx context.Context, a string) (AOut, error) {
	time.Sleep(10 * time.Millisecond) // gi·∫£ l·∫≠p x·ª≠ l√Ω nhanh
	select {
	case <-ctx.Done():
		return "", ctx.Err()
	default:
		return AOut("A:" + a), nil
	}
}

func getResultB(ctx context.Context, b string) (BOut, error) {
	time.Sleep(15 * time.Millisecond)
	select {
	case <-ctx.Done():
		return "", ctx.Err()
	default:
		return BOut("B:" + b), nil
	}
}

func getResultC(ctx context.Context, in CIn) (COut, error) {
	time.Sleep(10 * time.Millisecond)
	select {
	case <-ctx.Done():
		return "", ctx.Err()
	default:
		return COut(fmt.Sprintf("C(%s + %s)", in.A, in.B)), nil
	}
}

// --- C·∫•u tr√∫c processor ---
type processor struct {
	outA chan AOut
	outB chan BOut
	outC chan COut
	inC  chan CIn
	errs chan error
}

// --- Goroutine kh·ªüi ƒë·ªông ---
func (p *processor) launch(ctx context.Context, data Input) {
	go func() {
		aOut, err := getResultA(ctx, data.A)
		if err != nil {
			p.errs <- fmt.Errorf("getResultA failed: %w", err)
			return
		}
		p.outA <- aOut
	}()

	go func() {
		bOut, err := getResultB(ctx, data.B)
		if err != nil {
			p.errs <- fmt.Errorf("getResultB failed: %w", err)
			return
		}
		p.outB <- bOut
	}()

	go func() {
		select {
		case <-ctx.Done():
			return
		case inputC := <-p.inC:
			cOut, err := getResultC(ctx, inputC)
			if err != nil {
				p.errs <- fmt.Errorf("getResultC failed: %w", err)
				return
			}
			p.outC <- cOut
		}
	}()
}

// --- ƒê·ª£i k·∫øt qu·∫£ A v√† B ---
func (p *processor) waitForAB(ctx context.Context) (CIn, error) {
	var input CIn
	count := 0
	for count < 2 {
		select {
		case a := <-p.outA:
			input.A = a
			count++
		case b := <-p.outB:
			input.B = b
			count++
		case err := <-p.errs:
			return CIn{}, err
		case <-ctx.Done():
			return CIn{}, ctx.Err()
		}
	}
	return input, nil
}

// --- ƒê·ª£i k·∫øt qu·∫£ C ---
func (p *processor) waitForC(ctx context.Context) (COut, error) {
	select {
	case out := <-p.outC:
		return out, nil
	case err := <-p.errs:
		return "", err
	case <-ctx.Done():
		return "", ctx.Err()
	}
}

// --- H√†m ch√≠nh ---
func GatherAndProcess(ctx context.Context, data Input) (COut, error) {
	ctx, cancel := context.WithTimeout(ctx, 50*time.Millisecond)
	defer cancel()

	p := processor{
		outA: make(chan AOut, 1),
		outB: make(chan BOut, 1),
		inC:  make(chan CIn, 1),
		outC: make(chan COut, 1),
		errs: make(chan error, 2),
	}

	p.launch(ctx, data)

	inputC, err := p.waitForAB(ctx)
	if err != nil {
		return "", err
	}

	p.inC <- inputC
	return p.waitForC(ctx)
}

// --- Ki·ªÉm th·ª≠ ---
func main() {
	ctx := context.Background()

	data := Input{A: "foo", B: "bar"}
	out, err := GatherAndProcess(ctx, data)
	if err != nil {
		fmt.Println("‚ùå Error:", err)
	} else {
		fmt.Println("‚úÖ Success:", out)
	}
}
```

**K·∫øt qu·∫£ v√≠ d·ª•:**

```
‚úÖ Success: C(A:foo + B:bar)
```

## Khi n√†o n√™n s·ª≠ d·ª•ng mutex thay th·∫ø cho channel ƒë·ªÉ qu·∫£n l√Ω concurrency

**T·ªïng quan**
Trong Go c√≥ 2 c√¥ng c·ª• ch√≠nh ƒë·ªÉ x·ª≠ l√Ω concurrency

- `channel`: ƒë·ªÉ truy·ªÅn data gi·ªØa c√°c goroutine
- `mutex`: ƒë·ªÉ b·∫£o v·ªá truy c·∫≠p ƒë·ªìng th·ªùi t·ªõi t√†i nguy√™n d√πng chung (shared data)

**T·∫°i sao channel th∆∞·ªùng ƒë∆∞·ª£c ∆∞u ti√™n h∆°n mutex?**

- `Channel l√†m r√µ lu·ªìng d·ªØ li·ªáu:` khi d·ªØ li·ªáu ƒëi qua c√°c goroutine b·∫±ng channel, d·ªÖ hi·ªÉu h∆°n v·ªÅ th·ª© t·ª± v√† ti·∫øn tr√¨nh x·ª≠ l√Ω.
- `Mutex che gi·∫•u lu·ªìng d·ªØ li·ªáu:` khi nhi·ªÅu goroutine c√πng truy c·∫≠p v√†o m·ªôt bi·∫øn ƒë∆∞·ª£c b·∫£o v·ªá b·ªüi mutex, b·∫°n kh√¥ng th·ªÉ bi·∫øt r√µ goroutine n√†o ƒëang s·ª≠ d·ª•ng d·ªØ li·ªáu ‚Äì l√†m cho logic ch∆∞∆°ng tr√¨nh kh√≥ theo d√µi h∆°n.

**üß™ Khi n√†o n√™n d√πng mutex?**
D√π channel r·∫•t m·∫°nh, nh∆∞ng c√≥ `m·ªôt s·ªë tr∆∞·ªùng h·ª£p` mutex l·∫°i l√† l·ª±a ch·ªçn t·ªët h∆°n:

- `Khi c√°c goroutine ch·ªâ ƒë·ªçc/ghi gi√° tr·ªã chung, nh∆∞ng kh√¥ng c·∫ßn x·ª≠ l√Ω (process) gi√° tr·ªã ƒë√≥.`

V√≠ d·ª• trong ch∆∞∆°ng l√† m·ªôt b·∫£ng ƒëi·ªÉm (scoreboard) cho tr√≤ ch∆°i multiplayer. C√≥ hai c√°ch ti·∫øp c·∫≠n:

‚úÖ C√°ch 1: D√πng channel

```
func scoreboardManager(in <-chan func(map[string]int), done <-chan struct{}) {
	scoreboard := map[string]int{}
	for {
		select {
		case <-done:
			return
		case f := <-in:
			f(scoreboard)
		}
	}
}
```

M·ªói khi b·∫°n mu·ªën c·∫≠p nh·∫≠t ho·∫∑c ƒë·ªçc d·ªØ li·ªáu, b·∫°n truy·ªÅn m·ªôt `h√†m` v√†o channel, h√†m ƒë√≥ nh·∫≠n map scoreboard l√†m ƒë·ªëi s·ªë ƒë·ªÉ th·ª±c hi·ªán thay ƒë·ªïi.

∆Øu ƒëi·ªÉm:

- D·ªÖ ƒë·∫£m b·∫£o ch·ªâ 1 goroutine truy c·∫≠p scoreboard t·∫°i m·ªôt th·ªùi ƒëi·ªÉm.
- An to√†n v·ªÅ m·∫∑t concurrent.

Nh∆∞·ª£c ƒëi·ªÉm:

- `C·ªìng k·ªÅnh,` ƒë·∫∑c bi·ªát v·ªõi vi·ªác ƒë·ªçc (v√¨ ph·∫£i t·∫°o channel done ƒë·ªÉ ch·ªù k·∫øt qu·∫£ tr·∫£ v·ªÅ).
- `Ch·∫≠m` khi c√≥ nhi·ªÅu thao t√°c nh·ªè.

‚úÖ C√°ch 2: D√πng mutex

```
type MutexScoreboardManager struct {
	l          sync.RWMutex
	scoreboard map[string]int
}
```

- RWMutex cho ph√©p nhi·ªÅu `reader` ƒë·ªìng th·ªùi, nh∆∞ng ch·ªâ m·ªôt `writer.`
- Lock() v√† Unlock() cho write.
- RLock() v√† RUnlock() cho read.

∆Øu ƒëi·ªÉm:

- `G·ªçn v√† r√µ r√†ng` h∆°n so v·ªõi d√πng channel.
- H·ªó tr·ª£ `ƒëa ƒë·ªçc, ƒë∆°n ghi ‚Üí` hi·ªáu su·∫•t cao trong c√°c t√¨nh hu·ªëng ƒë·ªçc nhi·ªÅu, ghi √≠t.

**ü§î Quy t·∫Øc l·ª±a ch·ªçn: Channel hay Mutex?**
Theo Concurrency in Go, ch·ªçn nh∆∞ sau:

- C·∫ßn truy·ªÅn d·ªØ li·ªáu qua nhi·ªÅu goroutine, x·ª≠ l√Ω t·ª´ng b∆∞·ªõc -> `Channel`
- Nhi·ªÅu goroutine ch·ªâ ƒë·ªçc/ghi m·ªôt bi·∫øn trong struct -> `Mutex/RWMutex`
- C·∫ßn t·ªëi ∆∞u hi·ªáu nƒÉng, channel g√¢y t·∫Øc ngh·∫Ωn -> `Mutex`

**‚ùå Tr√°nh d√πng sync.Map tr·ª´ khi...**
Go c√≥ cung c·∫•p sync.Map, m·ªôt map an to√†n khi d√πng nhi·ªÅu goroutine, nh∆∞ng n√≥ `kh√¥ng ph·∫£i l√† map th√¥ng th∆∞·ªùng`:

- T·ªët khi `ghi 1 l·∫ßn, ƒë·ªçc nhi·ªÅu l·∫ßn.`
- Khi c√°c `goroutine kh√¥ng ch·∫°m v√†o key c·ªßa nhau.`
- Nh∆∞ng sync.Map d√πng interface{} n√™n d·ªÖ l·ªói ki·ªÉu ‚Üí kh√¥ng n√™n l·∫°m d·ª•ng.

`üëâ Trong h·∫ßu h·∫øt c√°c tr∆∞·ªùng h·ª£p, b·∫°n n√™n d√πng map + RWMutex.`
