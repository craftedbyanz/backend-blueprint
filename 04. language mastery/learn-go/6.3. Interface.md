# Interfaces

## Interfaces trong Go l√† g√¨?

Trong Go, interface l√† ki·ªÉu tr·ª´u t∆∞·ª£ng duy nh·∫•t. Ch√∫ng kh√¥ng y√™u c·∫ßu khai b√°o r√µ r√†ng vi·ªác m·ªôt struct "implement" m·ªôt interface nh∆∞ trong Java hay C#.

- Go d√πng implicit implementation ‚Äî m·ªôt t√≠nh nƒÉng r·∫•t m·∫°nh v√† linh ho·∫°t.

**Khai b√°o interface trong Go**

```
type Stringer interface {
    String() string
}
```

### üß† Kh√°i ni·ªám method set

> Method set l√† t·∫≠p h·ª£p c√°c ph∆∞∆°ng th·ª©c ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a tr√™n m·ªôt ki·ªÉu c·ª• th·ªÉ
> Ph·∫ßn trong interface ‚Äî danh s√°ch c√°c h√†m nh∆∞ String() string ‚Äî ƒë∆∞·ª£c g·ªçi l√† `method set.`

- N·∫øu m·ªôt struct c√≥ method t∆∞∆°ng ·ª©ng v·ªõi to√†n b·ªô method set c·ªßa m·ªôt interface ‚Üí n√≥ `th·ªèa m√£n` interface ƒë√≥.
- ƒêi·ªÅu n√†y √°p d·ª•ng t·ª± ƒë·ªông v√† kh√¥ng c·∫ßn c√∫ ph√°p ƒë·∫∑c bi·ªát.

> T√πy v√†o vi·ªác b·∫°n d√πng value receiver hay pointer receiver, method set c·ªßa gi√° tr·ªã v√† con tr·ªè c√≥ th·ªÉ kh√°c nhau.

**Method set c·ªßa value v√† pointer kh√°c nhau nh∆∞ th·∫ø n√†o?**
V·ªõi m·ªôt ki·ªÉu T, c√≥ hai t√¨nh hu·ªëng:

- Ki·ªÉu d√πng `T (gi√° tr·ªã)`: Method set bao g·ªìm - C√°c method c√≥ receiver l√† T
- Ki·ªÉu d√πng `*T (con tr·ªè)`: Method set bao g·ªìm - C√°c method c√≥ receiver l√† T v√† \*T

```
package main

import "fmt"

type Person struct {
    Name string
}

// Method v·ªõi receiver l√† value
func (p Person) SayHello() {
    fmt.Println("Hello, my name is", p.Name)
}

// Method v·ªõi receiver l√† pointer
func (p *Person) ChangeName(newName string) {
    p.Name = newName
}
```

Ph√¢n t√≠ch method set:

- Method set c·ªßa Person (gi√° tr·ªã):
  -SayHello()
- Method set c·ªßa \*Person (con tr·ªè):
  - SayHello()
  - ChangeName()

### üìõ T√™n interface k·∫øt th√∫c b·∫±ng -er

> ƒê√¢y l√† convention (quy ∆∞·ªõc) r·∫•t ph·ªï bi·∫øn trong Go:

## Interfaces trong Go ch√≠nh l√† ‚Äútype-safe duck typing.‚Äù

**ü¶Ü Type-Safe Duck Typing l√† g√¨?**

> Trong c√°c ng√¥n ng·ªØ ƒë·ªông nh∆∞ Python, Ruby, JavaScript ‚Äî kh√¥ng c·∫ßn khai b√°o m·ªôt interface. Ch·ªâ c·∫ßn ƒë·ªëi t∆∞·ª£ng c√≥ method ƒë√∫ng t√™n th√¨ c√≥ th·ªÉ truy·ªÅn v√†o function. ƒê√≥ l√† duck typing.

**üí° Go: C√°ch ti·∫øp c·∫≠n k·∫øt h·ª£p (Hybrid)**
Go d√πng implicit interface:

- Kh√¥ng c·∫ßn implements.
- Ch·ªâ c·∫ßn struct c√≥ ƒë·∫ßy ƒë·ªß c√°c method l√† t·ª± ƒë·ªông th·ªèa m√£n interface.

```
type Logic interface {
    Process(data string) string
}

type LogicProvider struct{}
func (lp LogicProvider) Process(data string) string {
    return "Processed: " + data
}

type Client struct {
    L Logic
}

func (c Client) Program() {
    c.L.Process("data")
}

func main() {
    c := Client{L: LogicProvider{}}
    c.Program()
}
```

### Embedding ‚Äî kh√¥ng ch·ªâ d√πng cho struct, m√† c√≤n d√πng ƒë∆∞·ª£c cho interface.

> B·∫°n c√≥ th·ªÉ embed interface n√†y v√†o trong interface kh√°c ƒë·ªÉ t·∫°o ra m·ªôt interface ph·ª©c t·∫°p h∆°n t·ª´ c√°c interface ƒë∆°n gi·∫£n.

```
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

type ReadCloser interface {
    Reader
    Closer
}

// C√°ch d√πng
func process(rc io.ReadCloser) {
    buf := make([]byte, 100)
    rc.Read(buf)
    rc.Close()
}

```

> ReadCloser l√† interface t·ªïng h·ª£p ‚Äî `y√™u c·∫ßu type ph·∫£i implement c·∫£ Read(...) v√† Close()`. ƒê√¢y l√† c√°ch t·∫°o `interface m·ªü r·ªông` trong Go.

#### Embedding Interface in a Struct?

B·∫°n c√≥ th·ªÉ `nh√∫ng m·ªôt interface v√†o trong struct` ƒë·ªÉ:

- `promote c√°c method t·ª´ interface`
- l√†m cho struct `‚Äúh√†nh x·ª≠ nh∆∞‚Äù` interface ƒë√≥, mi·ªÖn l√† n√≥ c√≥ method ph√π h·ª£p.

> Khi b·∫°n embed m·ªôt interface v√†o struct, t·ª©c l√† b·∫°n ƒë∆∞a interface ƒë√≥ v√†o struct nh∆∞ m·ªôt field ·∫©n danh:

```
type Printer interface {
    Print()
}

type MyPrinter struct{}

func (m MyPrinter) Print() {
    fmt.Println("Hello from MyPrinter")
}

type Wrapper struct {
    Printer // embedding interface
}
```

> N·∫øu b·∫°n g√°n m·ªôt MyPrinter v√†o field Printer c·ªßa Wrapper, b·∫°n c√≥ th·ªÉ g·ªçi method Print() tr·ª±c ti·∫øp tr√™n Wrapper.

**V√≠ d·ª•**

```
package main

import "fmt"

// Interface
type Greeter interface {
    Greet()
}

// Struct implement Greeter
type EnglishGreeter struct{}

func (e EnglishGreeter) Greet() {
    fmt.Println("Hello!")
}

// Embed interface v√†o struct
type App struct {
    Greeter // embedded interface
}

func main() {
    app := App{
        Greeter: EnglishGreeter{}, // g√°n implementation v√†o interface
    }

    app.Greet() // g·ªçi tr·ª±c ti·∫øp nh·ªù embedded interface
}
```

- App embed interface Greeter.
- App c√≥ th·ªÉ g·ªçi tr·ª±c ti·∫øp Greet() nh∆∞ th·ªÉ App implement interface n√†y ‚Äì nh∆∞ng th·ª±c ra l√† n√≥ ·ªßy quy·ªÅn cho Greeter ƒë√£ ƒë∆∞·ª£c g√°n (·ªü ƒë√¢y l√† EnglishGreeter{}).
- N·∫øu b·∫°n kh√¥ng g√°n Greeter, g·ªçi app.Greet() s·∫Ω g√¢y panic do nil interface.

## ‚úÖ Nguy√™n t·∫Øc: Accept Interfaces, Return Structs

### 1. Accept Interfaces (Nh·∫≠n v√†o l√† interface) - TƒÉng t√≠nh linh ho·∫°t & decoupling

- Khi vi·∫øt h√†m ho·∫∑c method, b·∫°n n√™n khai b√°o ki·ªÉu tham s·ªë l√† interface ‚Äî ch·ªâ c·∫ßn ƒë√∫ng method set b·∫°n s·ª≠ d·ª•ng.
- ƒêi·ªÅu n√†y l√†m cho h√†m:
  - `linh ho·∫°t` h∆°n (nh·∫≠n nhi·ªÅu lo·∫°i type kh√°c nhau)
  - `√≠t ph·ª• thu·ªôc h∆°n` (ch·ªâ ph·ª• thu·ªôc v√†o h√†nh vi, kh√¥ng ph·∫£i implementation c·ª• th·ªÉ)

```
type Writer interface {
    Write(p []byte) (n int, err error)
}

func LogMessage(w Writer, msg string) {
    w.Write([]byte(msg))
}
```

> H√†m LogMessage c√≥ th·ªÉ d√πng v·ªõi os.Stdout, bytes.Buffer, net.Conn, ... b·∫•t k·ª≥ type n√†o implement Writer.

### 2. Return Structs (Tr·∫£ v·ªÅ l√† struct) - Tr√°nh ph·ª• thu·ªôc kh√¥ng c·∫ßn thi·∫øt & d·ªÖ m·ªü r·ªông

> Khi vi·∫øt factory function ho·∫∑c API, b·∫°n n√™n tr·∫£ v·ªÅ `concrete type (struct)`, `kh√¥ng n√™n tr·∫£ v·ªÅ interface.`

**üß± L√Ω do:**
‚ùå Tr·∫£ v·ªÅ interface l√†m tƒÉng coupling:

- N·∫øu b·∫°n `tr·∫£ v·ªÅ interface` c·ªßa b√™n th·ª© ba, ng∆∞·ªùi d√πng code b·∫°n s·∫Ω `b·ªã ph·ª• thu·ªôc lu√¥n v√†o package ƒë√≥.`
- ƒêi·ªÅu n√†y g√¢y kh√≥ khƒÉn khi:
  - thay ƒë·ªïi package
  - n√¢ng version (d·ªÖ ph√° v·ª° backward compatibility)
  - mock hay test

‚ùå Interface breaking change:

- N·∫øu b·∫°n `th√™m method v√†o m·ªôt interface,` t·∫•t c·∫£ c√°c type implement interface ƒë√≥ `ph·∫£i c·∫≠p nh·∫≠t l·∫°i.`
- Nh∆∞ng n·∫øu b·∫°n th√™m method v√†o struct th√¨ client v·∫´n d√πng b√¨nh th∆∞·ªùng n·∫øu h·ªç kh√¥ng g·ªçi method m·ªõi ƒë√≥.

**üß™ V√≠ d·ª•: t·ªët vs x·∫•u**
‚ùå X·∫•u ‚Äì tr·∫£ v·ªÅ interface:

```
func NewLogger() Logger {
    return &fileLogger{}
}
```

B·∫•t k·ª≥ ai d√πng NewLogger() `ƒë·ªÅu ph·ª• thu·ªôc v√†o interface` Logger. N·∫øu b·∫°n ƒë·ªïi ho·∫∑c m·ªü r·ªông interface ƒë√≥, h·ªç s·∫Ω b·ªã ·∫£nh h∆∞·ªüng.

‚úÖ T·ªët ‚Äì tr·∫£ v·ªÅ struct:

```
func NewFileLogger() *FileLogger {
    return &FileLogger{}
}
```

- Ng∆∞·ªùi d√πng v·∫´n c√≥ th·ªÉ wrap n√≥ b·∫±ng interface n·∫øu h·ªç mu·ªën.
- B·∫°n c√≥ th·ªÉ m·ªü r·ªông FileLogger m√† kh√¥ng ph√° v·ª° backward compatibility.

**üö® Ngo·∫°i l·ªá: Tr·∫£ v·ªÅ error interface**
ƒê√¢y l√† `ngo·∫°i l·ªá h·ª£p l√Ω duy nh·∫•t` v√¨:

- error l√† interface duy nh·∫•t c√≥ s·∫µn trong Go.
- C√≥ th·ªÉ tr·∫£ v·ªÅ nhi·ªÅu lo·∫°i l·ªói kh√°c nhau.
- Caller ch·ªâ c·∫ßn x·ª≠ l√Ω theo error, kh√¥ng quan t√¢m l√† l·ªói c·ª• th·ªÉ n√†o.

```
func DoSomething() error {
    return errors.New("something went wrong")
}
```

### üß† ƒêi·ªÉm c·ªët l√µi: Interface ch·ªâ th·ª±c s·ª± nil n·∫øu c·∫£ type l·∫´n value ƒë·ªÅu nil

> ‚úÖ interface == nil ‚ü∫ type == nil && value == nil

```
interface {
   type:   *SomeType
   value:  actual value
}

var s *string
fmt.Println(s == nil)  // ‚úÖ true ‚Äì s l√† nil pointer

var i interface{}
fmt.Println(i == nil)  // ‚úÖ true ‚Äì i ch∆∞a g√°n g√¨ c·∫£, nil interface (type=nil, value=nil)

i = s
fmt.Println(i == nil)  // ‚ùå false ‚Äì i ƒëang ch·ª©a (type=*string, value=nil)
```

####‚ùó T√°c h·∫°i th·ª±c t·∫ø
**‚ö†Ô∏è 1. L·ªói logic: b·∫°n nghƒ© gi√° tr·ªã nil nh∆∞ng th·ª±c ra kh√¥ng ph·∫£i**

```
func doSomething(err error) {
	if err == nil {
		fmt.Println("No error")  // ‚ùå ƒê√¢y c√≥ th·ªÉ kh√¥ng ƒë√∫ng!
	}
}
```

> N·∫øu err l√† m·ªôt interface error ch·ª©a m·ªôt gi√° tr·ªã nil \*MyError, th√¨ err != nil, v√† h√†m s·∫Ω kh√¥ng in ra ‚ÄúNo error‚Äù nh∆∞ mong ƒë·ª£i.
> **‚ö†Ô∏è 2. Panic n·∫øu g·ªçi method tr√™n gi√° tr·ªã nil b√™n trong interface**

```
type MyType struct{}

func (m *MyType) Do() {
	fmt.Println("Do something")
}

func main() {
	var m *MyType = nil
	var i interface{} = m
	i.(MyTypeInterface).Do()  // üí• panic: nil pointer dereference
}
```

## The Empty Interface Says Nothing

**üìå 1. interface{} nghƒ©a l√† ‚Äúany type‚Äù trong Go**
Trong Go, interface{} l√† interface tr·ªëng, nghƒ©a l√† n√≥ kh√¥ng y√™u c·∫ßu b·∫•t k·ª≥ method n√†o.

> ‚û°Ô∏è V√¨ m·ªçi type trong Go ƒë·ªÅu c√≥ √≠t nh·∫•t l√† zero method, m·ªçi type ƒë·ªÅu ‚Äúimplements‚Äù interface{}.

```
var i interface{}
i = 42
i = "hello"
i = SomeStruct{"abc", 123}
```

### üß† V·∫≠y interface{} d√πng l√†m g√¨?

**1. üì¶ D·ªØ li·ªáu kh√¥ng bi·∫øt tr∆∞·ªõc schema (th∆∞·ªùng l√† JSON)**
Khi ƒë·ªçc t·ª´ m·ªôt ngu·ªìn d·ªØ li·ªáu linh ho·∫°t (JSON, YAML, v.v.), ta kh√¥ng bi·∫øt ki·ªÉu c·ª• th·ªÉ l√† g√¨.

```
data := map[string]interface{}{}

contents, err := ioutil.ReadFile("testdata/sample.json")
if err != nil {
    return err
}
json.Unmarshal(contents, &data)
```

> ‚û°Ô∏è Sau khi Unmarshal, data["foo"] c√≥ th·ªÉ l√† string, float64, bool, map[string]interface{}... t√πy v√†o JSON g·ªëc.

**2. üîÅ T·ª± vi·∫øt data structure d√πng cho nhi·ªÅu lo·∫°i d·ªØ li·ªáu (tr∆∞·ªõc khi Go c√≥ generics)**

```
type LinkedList struct {
	Value interface{}
	Next  *LinkedList
}

func (ll *LinkedList) Insert(pos int, val interface{}) *LinkedList {
	if ll == nil || pos == 0 {
		return &LinkedList{Value: val, Next: ll}
	}
	ll.Next = ll.Next.Insert(pos-1, val)
	return ll
}
```

**‚ö†Ô∏è 3. T·∫°i sao n√™n tr√°nh d√πng interface{}?**

- Kh√¥ng c√≥ th√¥ng tin g√¨ v·ªÅ gi√° tr·ªã: kh√¥ng bi·∫øt type l√† g√¨, kh√¥ng g·ªçi ƒë∆∞·ª£c method n√†o.
- R·∫•t d·ªÖ m·∫Øc l·ªói t·∫°i runtime n·∫øu x·ª≠ l√Ω sai type.
- Kh√¥ng ph·∫£i c√°ch vi·∫øt ‚Äúidiomatic‚Äù trong Go (tr·ª´ khi th·ª±c s·ª± c·∫ßn).

#### üîç 4. V·∫≠y n·∫øu ƒë√£ d√πng interface{} r·ªìi, l√†m sao l·∫•y gi√° tr·ªã ra?

**Type assertion:**

```
val := i.(string)       // panic n·∫øu i kh√¥ng ph·∫£i string
val, ok := i.(string)   // an to√†n h∆°n
```

**Type switch:**

```
switch v := i.(type) {
case string:
    fmt.Println("Got string:", v)
case int:
    fmt.Println("Got int:", v)
default:
    fmt.Println("Unknown type")
}
```

## Type Assertions and Type Switches

Trong Go, khi l√†m vi·ªác v·ªõi bi·∫øn interface, ƒë√¥i khi b·∫°n c·∫ßn bi·∫øt:

- `Gi√° tr·ªã b√™n trong thu·ªôc ki·ªÉu g√¨ (concrete type)?`
- `C√≥ ph·∫£i n√≥ implements m·ªôt interface kh√°c kh√¥ng?`

Go cung c·∫•p 2 c√¥ng c·ª• ch√≠nh ƒë·ªÉ l√†m vi·ªác n√†y:

### 1. üß© Type Assertion ‚Äì ‚ÄúT√¥i kh·∫≥ng ƒë·ªãnh ƒë√¢y l√† ki·ªÉu X‚Äù - ch·ªâ √°p d·ª•ng ƒë∆∞·ª£c n·∫øu b·∫°n bi·∫øt tr∆∞·ªõc v√†i ki·ªÉu c√≥ th·ªÉ x·∫£y ra. D√πng cho 1 ki·ªÉu c·ª• th·ªÉ

```
v, ok := i.(string)
if !ok {
    fmt.Println("Kh√¥ng ph·∫£i string")
} else {
    fmt.Println("ƒê√¢y l√† string:", v)
}
```

### 2. üåÄ Type Switch ‚Äì ‚ÄúT√¥i ki·ªÉm tra th·ª≠ xem n√≥ l√† ki·ªÉu n√†o‚Äù - Ki·ªÉm tra nhi·ªÅu ki·ªÉu c√πng l√∫c. D√πng khi c√≥ nhi·ªÅu kh·∫£ nƒÉng v·ªÅ ki·ªÉu

```
switch v := i.(type) {
case int:
    fmt.Println("L√† s·ªë:", v)
case string:
    fmt.Println("L√† chu·ªói:", v)
case MyType:
    fmt.Println("L√† ki·ªÉu MyType:", v)
case nil:
    fmt.Println("Gi√° tr·ªã l√† nil")
default:
    fmt.Println("Kh√¥ng r√µ l√† ki·ªÉu g√¨")
}
```

## Function Types Are a Bridge to Interfaces

B·∫°n c√≥ th·ªÉ bi·∫øn m·ªôt h√†m (function) th√†nh m·ªôt ‚Äúƒë·ªëi t∆∞·ª£ng‚Äù c√≥ th·ªÉ g·ªçi ƒë∆∞·ª£c c√°c ph∆∞∆°ng th·ª©c (methods) ‚Äî b·∫±ng c√°ch t·∫°o m·ªôt ki·ªÉu h√†m (function type) v√† th√™m method cho n√≥.

**V√≠ d·ª• ƒë∆°n gi·∫£n:**
Gi·∫£ s·ª≠ b·∫°n c√≥ m·ªôt h√†m x·ª≠ l√Ω HTTP ki·ªÉu n√†y:

```
func myHandler(w http.ResponseWriter, r *http.Request) {
    // X·ª≠ l√Ω request ·ªü ƒë√¢y
}

```

Nh∆∞ng Go y√™u c·∫ßu m·ªôt ƒë·ªëi t∆∞·ª£ng c√≥ method ServeHTTP(w, r) ƒë·ªÉ l√†m handler, nh∆∞ interface n√†y:

```
type Handler interface {
    ServeHTTP(http.ResponseWriter, *http.Request)
}
```

V·∫≠y b·∫°n l√†m th·∫ø n√†o ƒë·ªÉ d√πng lu√¥n h√†m myHandler l√†m Handler?

**Gi·∫£i ph√°p:**

```
// 1. T·∫°o m·ªôt ki·ªÉu m·ªõi ‚Äî ƒë√≥ l√† ki·ªÉu h√†m:
type HandlerFunc func(http.ResponseWriter, *http.Request)

// 2. Th√™m method ServeHTTP cho ki·ªÉu n√†y:
func (f HandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    f(w, r)  // g·ªçi ch√≠nh h√†m f ƒë√≥
}

3. Gi·ªù b·∫°n c√≥ th·ªÉ chuy·ªÉn h√†m myHandler th√†nh HandlerFunc r·ªìi d√πng n√≥ nh∆∞ m·ªôt Handler:
var h Handler = HandlerFunc(myHandler)
```

**T√≥m t·∫Øt**

- B·∫°n c√≥ m·ªôt h√†m (function).
- B·∫°n mu·ªën h√†m ƒë√≥ ƒë∆∞·ª£c x·ª≠ l√Ω nh∆∞ m·ªôt ƒë·ªëi t∆∞·ª£ng (object) c√≥ th·ªÉ g·ªçi method.
- B·∫°n t·∫°o ki·ªÉu h√†m m·ªõi (function type).
- R·ªìi g√°n th√™m method cho ki·ªÉu h√†m ƒë√≥.
- Khi g·ªçi method n√†y, n√≥ ch·ªâ g·ªçi th·∫≥ng h√†m b√™n trong.

Nh∆∞ v·∫≠y, h√†m tr·ªü th√†nh m·ªôt ƒë·ªëi t∆∞·ª£ng th·ªèa m√£n interface.

**T·∫°i sao l·∫°i l√†m v·∫≠y?**

- Trong Go, interface ch·ªâ c·∫ßn 1 method c≈©ng r·∫•t m·∫°nh.
- N·∫øu b·∫°n ch·ªâ c·∫ßn truy·ªÅn 1 h√†m ƒë∆°n gi·∫£n, thay v√¨ t·∫°o m·ªôt struct ph·ª©c t·∫°p, b·∫°n c√≥ th·ªÉ t·∫≠n d·ª•ng ki·ªÉu h√†m c√≥ method.
- ƒêi·ªÅu n√†y gi√∫p code ng·∫Øn g·ªçn, linh ho·∫°t v√† idiomatic (ƒë√∫ng chu·∫©n Go).

> `B·∫°n c√≥ h√†m ƒë∆°n` -> `B·∫°n c·∫ßn object c√≥ method`: Mu·ªën th·ªèa interface (c√≥ method) -> `Gi·∫£i ph√°p`: T·∫°o function type + th√™m method g·ªçi h√†m ƒë√≥
