## Prefix sum
- Prefix sum là mảng phụ được xây dựng sao cho mỗi phần tử của nó lưu tổng của tất cả phần tử trong mảng gốc từ đầu tới vị trí đó.

> current_sum = tổng các phần tử từ đầu mảng đến vị trí hiện tại i. (Gọi đây là prefix sum tại i)
>
> prefix_sum[j] = tổng các phần tử từ đầu mảng đến vị trí j.

Ví dụ:
```
nums = [3, 1, 4, 2]
prefix = [3, 4, 8, 10]

i     : 0   1   2    3
nums  : 3   1   4    2
prefix: 3   4   8   10
```

`prefix[i] = nums[0] + nums[1] + ... + nums[i]`

## Công thức tổng đoạn bất kỳ

> Một lợi ích cực lớn của prefix sum là tính nhanh tổng của bất kỳ đoạn [l, r]:

```
sum(l, r) = prefix[r] - prefix[l - 1]   (nếu l > 0)
sum(0, r) = prefix[r]
```

Ví dụ: tổng từ nums[1] đến nums[3]:
```
prefix[3] - prefix[0] = 10 - 3 = 7  ✅
```

> ⏱ Tính trong O(1) thay vì O(n) mỗi lần.

## Ứng dụng
📍 Bài toán điển hình
1. `Tổng đoạn liên tục` nhiều lần query → prefix sum giảm từ O(n·q) xuống O(n+q)
2. `Kiểm tra mảng con thoả điều kiện tổng` (ví dụ: subarray sum bằng k)
3. Tối ưu sliding window khi độ dài cố định
4. 2D Prefix Sum cho bài matrix (tính tổng hình chữ nhật nhanh)

## Code Python
```
def prefix_sum(nums):
    n = len(nums)
    prefix = [0] * n
    prefix[0] = nums[0]
    for i in range(1, n):
        prefix[i] = prefix[i-1] + nums[i]
    return prefix

nums = [3, 1, 4, 2]
prefix = prefix_sum(nums)
print(prefix)  # [3, 4, 8, 10]

# Tính tổng từ index 1 → 3
l, r = 1, 3
total = prefix[r] - (prefix[l-1] if l > 0 else 0)
print(total)  # 7
```

## Mẹo & Best Practice
- Khi bài có nhiều lần query tổng subarray → nghĩ ngay prefix sum.

- Nếu nums rất lớn nhưng query ít → không cần prefix sum.

- Nếu mảng có thể update giá trị nhiều → prefix sum thường kém hiệu quả (dùng Fenwick Tree hoặc Segment Tree).

- Prefix sum 2D (Matrix) giúp trả lời query tổng hình chữ nhật O(1) sau O(n·m) preprocessing.

- Với subarray sum = k → kết hợp prefix sum + hash map để giải O(n).

## Prefix Sum + Hash Map (nâng cao)
Ex: Subarray Sum Equals K 
- Cho mảng nums và số nguyên k, đếm số subarray liên tiếp có tổng bằng k.
```
nums = [1, 1, 1], k = 2
Subarrays: [1,1] (0..1), [1,1] (1..2) → output = 2
```
Ý tưởng:
- Lưu prefix_sum tại mỗi vị trí.
- Nếu prefix_sum[j] - prefix_sum[i-1] = k ⇒ tồn tại đoạn từ i → j có tổng = k.
- Hash map lưu tần suất prefix_sum đã gặp.

```
def subarraySum(nums, k):
    prefix_sum = 0
    count = 0
    freq = {0: 1}  # prefix_sum = 0 xuất hiện 1 lần

    for num in nums:
        prefix_sum += num
        if prefix_sum - k in freq:
            count += freq[prefix_sum - k]
        freq[prefix_sum] = freq.get(prefix_sum, 0) + 1
    return count
```